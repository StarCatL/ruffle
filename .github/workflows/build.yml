name: Release Nightly

on:
  schedule:
    - cron: "0 0 * * *"
  workflow_dispatch:

env:
  RELEASE_SCRIPT: ./.github/scripts/release.py

jobs:
  create-nightly-release:
    name: Create Nightly Release
    runs-on: ubuntu-24.04
    outputs:
      is_active: ${{ steps.activity.outputs.is_active }}
      date: ${{ steps.current_time_underscores.outputs.formattedTime }}
      upload_url: ${{ steps.create_release.outputs.upload_url }}
      package_prefix: ${{ steps.create_release.outputs.package_prefix }}
      tag_name: ${{ steps.create_release.outputs.tag_name }}
      version4: ${{ steps.version.outputs.version4 }}

    if: github.repository == 'ruffle-rs/ruffle' || github.event_name == 'repository_dispatch' || github.event_name == 'workflow_dispatch'

    steps:
      - uses: actions/checkout@v4

      - name: Check for repo activity
        id: activity
        run: |
          if [ "${{ github.event_name }}" == "repository_dispatch" ] || [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            is_active=true
          elif [ "$(git rev-list --after="24 hours" ${{ github.sha }})" ]; then
            is_active=true
          else
            is_active=false
          fi
          echo "is_active=$is_active" >> $GITHUB_OUTPUT

      - name: Install cargo-edit
        uses: baptiste0928/cargo-install@v3
        with:
          crate: cargo-edit
          version: '^0.12'

      - name: Install cargo-get
        uses: baptiste0928/cargo-install@v3
        with:
          crate: cargo-get
          version: '^1.0'

      - name: Bump version
        if: steps.activity.outputs.is_active == 'true'
        id: version
        run: |
          $RELEASE_SCRIPT bump
          shopt -s globstar
          sed -i -e '$a\' **/package.json

      - name: Create release commit
        if: steps.activity.outputs.is_active == 'true'
        id: commit
        run: |
          git diff
          git diff > /tmp/nightly-release.patch
          revision=$(git rev-parse HEAD)
          echo "revision=$revision" | tee -a $GITHUB_OUTPUT

      - name: Upload nightly release patch
        uses: actions/upload-artifact@v4
        if: steps.activity.outputs.is_active == 'true'
        with:
          name: nightly-release-patch
          path: /tmp/nightly-release.patch

      - name: Get current time with underscores
        uses: josStorer/get-current-time@v2.1.2
        id: current_time_underscores
        with:
          format: YYYY_MM_DD

      - name: Create release
        if: steps.activity.outputs.is_active == 'true'
        id: create_release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          $RELEASE_SCRIPT release

  build:
    name: Build ${{ matrix.build_name }}
    needs: create-nightly-release
    if: needs.create-nightly-release.outputs.is_active == 'true'
    strategy:
      fail-fast: false
      matrix:
        include:
          - build_name: linux-aarch64
            os: ubuntu-24.04
            target: aarch64-unknown-linux-musl
            FEATURES: sandbox,jpegxr
            NO_DEFAULT_FEATURES: false
            MUSL_CROSS: true

    env:
      PACKAGE_FILE: ${{ needs.create-nightly-release.outputs.package_prefix }}-${{ matrix.build_name }}.tar.gz
      CARGO_BUILD_DIR: target/${{ matrix.target }}/release

    runs-on: ${{ matrix.os }}
    steps:
      - name: Clone Ruffle repo
        uses: actions/checkout@v4

      - name: Download nightly release patch
        uses: actions/download-artifact@v4
        with:
          name: nightly-release-patch
          path: /tmp

      - name: Apply nightly release patch
        run: git apply --verbose /tmp/nightly-release.patch

      - name: Install musl toolchain
        run: |
          sudo apt-get update
          sudo apt-get install -y musl-tools musl-dev linux-libc-dev linux-headers-generic
          
          # 安装 aarch64 musl 交叉编译工具链
          echo "安装 aarch64 musl 交叉编译工具链..."
          TOOLCHAIN_URL="https://toolchains.bootlin.com/downloads/releases/toolchains/aarch64/tarballs/aarch64--musl--stable-2023.11-1.tar.bz2"
          TOOLCHAIN_FILE="aarch64-musl-toolchain.tar.bz2"
          TOOLCHAIN_ROOT="/usr/local/aarch64-musl-toolchain"
          
          wget -O "$TOOLCHAIN_FILE" "$TOOLCHAIN_URL"
          sudo mkdir -p "$TOOLCHAIN_ROOT"
          sudo tar xf "$TOOLCHAIN_FILE" -C "$TOOLCHAIN_ROOT" --strip-components=1
          
          TOOLCHAIN_PATH="$TOOLCHAIN_ROOT/bin"
          SYSROOT_DIR="$TOOLCHAIN_ROOT/aarch64-buildroot-linux-musl/sysroot"
          echo "TOOLCHAIN_PATH=$TOOLCHAIN_PATH" >> $GITHUB_ENV
          echo "SYSROOT_DIR=$SYSROOT_DIR" >> $GITHUB_ENV
          echo "$TOOLCHAIN_PATH" >> $GITHUB_PATH
          
          # 创建必要的符号链接
          sudo ln -sf $SYSROOT_DIR/usr/include/linux /usr/include/linux
          sudo ln -sf $SYSROOT_DIR/usr/include/asm /usr/include/asm
          sudo ln -sf $SYSROOT_DIR/usr/include/asm-generic /usr/include/asm-generic

      - name: Set cross-compilation environment
        run: |
          echo "设置 aarch64 交叉编译环境..."
          echo "CC=$TOOLCHAIN_PATH/aarch64-buildroot-linux-musl-gcc" >> $GITHUB_ENV
          echo "CXX=$TOOLCHAIN_PATH/aarch64-buildroot-linux-musl-g++" >> $GITHUB_ENV
          echo "AR=$TOOLCHAIN_PATH/aarch64-buildroot-linux-musl-ar" >> $GITHUB_ENV
          echo "RANLIB=$TOOLCHAIN_PATH/aarch64-buildroot-linux-musl-ranlib" >> $GITHUB_ENV
          echo "PKG_CONFIG_ALLOW_CROSS=1" >> $GITHUB_ENV
          echo "PKG_CONFIG_SYSROOT_DIR=$SYSROOT_DIR" >> $GITHUB_ENV
          echo "PKG_CONFIG_PATH=$SYSROOT_DIR/usr/lib/pkgconfig" >> $GITHUB_ENV
          echo "RUSTFLAGS=-L$SYSROOT_DIR/usr/lib" >> $GITHUB_ENV
          echo "CFLAGS=--sysroot=$SYSROOT_DIR -I$SYSROOT_DIR/usr/include" >> $GITHUB_ENV
          echo "LDFLAGS=--sysroot=$SYSROOT_DIR -L$SYSROOT_DIR/usr/lib" >> $GITHUB_ENV
          
          # 设置 cargo 链接器
          echo "CARGO_TARGET_AARCH64_UNKNOWN_LINUX_MUSL_LINKER=$TOOLCHAIN_PATH/aarch64-buildroot-linux-musl-gcc" >> $GITHUB_ENV

      - name: Install musl target
        run: rustup target add ${{ matrix.target }}

      - name: Build dependencies for aarch64 musl
        run: |
          echo "安装构建工具..."
          # 确保安装meson和ninja-build
          sudo apt-get install -y meson ninja-build
          
          # 修复：安装Python依赖
          sudo apt-get install -y python3 python3-pip
          sudo pip3 install jinja2
          
          echo "构建 aarch64 musl 依赖库..."
          DEPS_DIR="/tmp/musl-deps"
          mkdir -p "$DEPS_DIR"
          cd "$DEPS_DIR"
          
          # 安装其他构建工具
          sudo apt-get install -y autoconf automake libtool m4 gcc gperf pkg-config
          
          # 构建 libcap
          LIBCAP_VERSION="2.69"
          wget "https://mirrors.edge.kernel.org/pub/linux/libs/security/linux-privs/libcap2/libcap-$LIBCAP_VERSION.tar.xz"
          tar xf "libcap-$LIBCAP_VERSION.tar.xz"
          cd "libcap-$LIBCAP_VERSION"
          
          # 修复：禁用共享库构建和测试
          sed -i 's/^\(BUILD_SHARED_LIB\)=yes/\1=no/' Make.Rules
          sed -i 's/^\(BUILD_STATIC_LIB\)=no/\1=yes/' Make.Rules
          sed -i 's/^\(BUILD_TESTS\)=yes/\1=no/' Make.Rules
          sed -i 's/^\(BUILD_EXAMPLES\)=yes/\1=no/' Make.Rules
          sed -i '/^include .*gobjs.mk/d' Makefile
          sed -i '/^include .*gperf.mk/d' Makefile
          
          # 设置内核头文件路径到 sysroot
          export KERNEL_HEADERS="$SYSROOT_DIR/usr/include"
          
          # 修改 Makefile 以使用正确的路径
          sed -i "s|^INCLUDE_HEADERS :=.*|INCLUDE_HEADERS := $KERNEL_HEADERS|" Make.Rules
          sed -i "s|^INCLUDE_HEADERS :=.*|INCLUDE_HEADERS := $KERNEL_HEADERS|" libcap/Makefile
          
          # 只构建静态库
          make BUILD_CC="gcc" \
               CC="$CC" \
               AR="$AR" \
               RANLIB="$RANLIB" \
               CFLAGS="$CFLAGS -I$PWD/libcap/include" \
               LDFLAGS="$LDFLAGS" \
               lib=lib prefix=/usr \
               -C libcap libcap.a
          
          # 手动安装到 sysroot
          sudo mkdir -p "$SYSROOT_DIR/usr/lib"
          sudo cp libcap/libcap.a "$SYSROOT_DIR/usr/lib"
          
          # 创建必要的头文件目录
          sudo mkdir -p "$SYSROOT_DIR/usr/include/sys"
          sudo mkdir -p "$SYSROOT_DIR/usr/include/linux"
          
          # 修复：使用正确的路径复制头文件
          sudo cp libcap/include/sys/capability.h "$SYSROOT_DIR/usr/include/sys/"
          
          # 修复：使用正确的uapi路径复制头文件
          sudo cp libcap/include/uapi/linux/capability.h "$SYSROOT_DIR/usr/include/linux/"
          
          # 创建 pkg-config 文件
          echo "prefix=$SYSROOT_DIR/usr" > libcap.pc
          echo "exec_prefix=\${prefix}" >> libcap.pc
          echo "libdir=\${exec_prefix}/lib" >> libcap.pc
          echo "includedir=\${prefix}/include" >> libcap.pc
          echo "" >> libcap.pc
          echo "Name: libcap" >> libcap.pc
          echo "Description: Linux capabilities library" >> libcap.pc
          echo "Version: $LIBCAP_VERSION" >> libcap.pc
          echo "Cflags: -I\${includedir}" >> libcap.pc
          echo "Libs: -L\${libdir} -lcap" >> libcap.pc
          
          sudo mkdir -p "$SYSROOT_DIR/usr/lib/pkgconfig"
          sudo cp libcap.pc "$SYSROOT_DIR/usr/lib/pkgconfig"
          
          cd ..
          
          # 构建 ALSA
          ALSA_VERSION="1.2.10"
          wget "https://www.alsa-project.org/files/pub/lib/alsa-lib-$ALSA_VERSION.tar.bz2"
          tar xf "alsa-lib-$ALSA_VERSION.tar.bz2"
          cd "alsa-lib-$ALSA_VERSION"
          
          # 修复ALSA构建问题：添加全局缺失的宏定义
          # 在全局头文件中定义缺失的宏
          echo "#define __STRING(x) #x" >> include/global.h
          echo "#define _dlsym_control_001 1" >> include/control.h
          echo "#define _dlsym_pcm_001 1" >> include/pcm.h
          
          # 配置ALSA
          ./configure \
            --host=aarch64-buildroot-linux-musl \
            --prefix="$SYSROOT_DIR/usr" \
            --enable-static \
            --disable-shared \
            --with-pic \
            --disable-python \
            CFLAGS="$CFLAGS" \
            LDFLAGS="$LDFLAGS"
            
          # 构建并安装
          make -j$(nproc)
          sudo make install
          cd ..
          
          # 构建 util-linux (提供 libblkid 和 libmount)
          UTIL_LINUX_VERSION="2.39.3"
          wget "https://mirrors.edge.kernel.org/pub/linux/utils/util-linux/v${UTIL_LINUX_VERSION%.*}/util-linux-$UTIL_LINUX_VERSION.tar.gz"
          tar xf "util-linux-$UTIL_LINUX_VERSION.tar.gz"
          cd "util-linux-$UTIL_LINUX_VERSION"
          
          # 修复：添加缺失的头文件宏
          cat > include/missing.h <<EOF
          #ifndef MISSING_H
          #define MISSING_H
          
          #define __STRING(x) #x
          #define _dlsym_control_001 1
          #define _dlsym_pcm_001 1
          
          #endif /* MISSING_H */
          EOF
          
          # 修复：添加缺失的 isnan 实现
          cat >> include/missing.h <<EOF
          
          #ifndef isnan
          #define isnan(x) __builtin_isnan(x)
          #endif
          EOF
          
          # 将自定义头文件包含到 config.h
          echo "#include \"missing.h\"" >> config.h.in
          
          # 配置 util-linux
          ./configure \
            --host=aarch64-buildroot-linux-musl \
            --prefix="$SYSROOT_DIR/usr" \
            --disable-all-programs \
            --enable-libblkid \
            --enable-libmount \
            --enable-static \
            --disable-shared \
            --without-python \
            --without-systemd \
            --without-udev \
            --without-ncurses \
            --without-ncursesw \
            --without-tinfo \
            --without-readline \
            --disable-makeinstall-chown \
            --disable-makeinstall-setuid \
            --without-btrfs \
            CFLAGS="$CFLAGS -I$PWD/include" \
            LDFLAGS="$LDFLAGS"
            
          # 构建并安装
          make -j$(nproc)
          sudo make install
          cd ..
          
          # 构建 libudev
          UDEV_VERSION="252"
          wget "https://github.com/systemd/systemd/archive/refs/tags/v$UDEV_VERSION.tar.gz"
          tar xf "v$UDEV_VERSION.tar.gz"
          cd "systemd-$UDEV_VERSION"
          
          # 创建交叉编译配置文件
          cat > cross-file.txt <<EOF
          [binaries]
          c = 'aarch64-buildroot-linux-musl-gcc'
          cpp = 'aarch64-buildroot-linux-musl-g++'
          ar = 'aarch64-buildroot-linux-musl-ar'
          strip = 'aarch64-buildroot-linux-musl-strip'
          pkgconfig = 'pkg-config'
          
          [host_machine]
          system = 'linux'
          cpu_family = 'aarch64'
          cpu = 'aarch64'
          endian = 'little'
          EOF
          
          # 关键修复：强制使用宿主机Python
          # 卸载工具链中的Python以避免干扰
          sudo rm -f "$TOOLCHAIN_PATH/python3"
          sudo rm -f "$TOOLCHAIN_PATH/python"
          
          # 确保使用宿主机Python
          export PATH="/usr/bin:$PATH"
          export PYTHON=/usr/bin/python3
          echo "使用Python路径: $PYTHON"
          
          # 验证Python环境
          which python3
          python3 -c "import jinja2; print('jinja2 is available')"
          
          # 使用有效的Meson选项
          meson setup \
            --cross-file cross-file.txt \
            -Dprefix="$SYSROOT_DIR/usr" \
            -Dmode=release \
            -Dtests=false \
            -Dlink-udev-shared=false \
            -Ddefault_library=static \
            -Dstatic-libudev=true \
            -Dman=false \
            -Ddbus=false \
            -Dutmp=false \
            -Dhibernate=false \
            -Dldconfig=false \
            -Dresolve=false \
            -Defi=false \
            -Dtpm=false \
            -Dadm-group=false \
            -Dwheel-group=false \
            -Dzlib=false \
            -Dgshadow=false \
            -Dima=false \
            -Dsmack=false \
            -Dgcrypt=false \
            -Dp11kit=false \
            -Dlibidn=false \
            -Dlibidn2=false \
            -Dlibiptc=false \
            -Delfutils=false \
            -Dbinfmt=false \
            -Drepart=false \
            -Dcoredump=false \
            -Dpolkit=false \
            -Dlogind=false \
            -Dhostnamed=false \
            -Dlocaled=false \
            -Dmachined=false \
            -Dnetworkd=false \
            -Dtimedated=false \
            -Dtimesyncd=false \
            -Dremote=false \
            -Dcreate-log-dirs=false \
            -Dnss-myhostname=false \
            -Dnss-mymachines=false \
            -Dnss-resolve=false \
            -Dnss-systemd=false \
            -Dfirstboot=false \
            -Drandomseed=false \
            -Dbacklight=false \
            -Dvconsole=false \
            -Dquotacheck=false \
            -Dsysusers=false \
            -Dtmpfiles=false \
            build \
            -Dc_args="$CFLAGS" \
            -Dc_link_args="$LDFLAGS"
          
          ninja -C build src/libudev/libudev.a
          sudo ninja -C build install
          cd ..
          
          # 验证安装
          echo "依赖库构建完成:"
          ls -l "$SYSROOT_DIR/usr/lib"/lib{cap,asound,udev,blkid,mount}.a
          echo "头文件验证:"
          ls -l "$SYSROOT_DIR/usr/include/sys/capability.h"
          ls -l "$SYSROOT_DIR/usr/include/linux/capability.h"
          ls -l "$SYSROOT_DIR/usr/include/blkid/blkid.h"
          ls -l "$SYSROOT_DIR/usr/include/libmount/libmount.h"

      - name: Cargo build
        run: |
          echo "构建 Ruffle 目标: ${{ matrix.target }}"
          cargo build --locked --package ruffle_desktop --release \
            --target ${{ matrix.target }} \
            --no-default-features \
            --features "${{ matrix.FEATURES }}"
        env:
          CFG_RELEASE_CHANNEL: nightly
          # 添加必要的静态链接参数
          CARGO_TARGET_AARCH64_UNKNOWN_LINUX_MUSL_RUSTFLAGS: "-C link-arg=-lcap -C link-arg=-ludev -C link-arg=-lasound -C link-arg=-lblkid -C link-arg=-lmount"

      - name: Verify static linking
        run: |
          BINARY="${{ env.CARGO_BUILD_DIR }}/ruffle_desktop"
          echo "验证静态链接: $BINARY"
          
          # 检查文件类型
          file "$BINARY"
          
          # 检查动态依赖
          if readelf -d "$BINARY" | grep NEEDED; then
            echo "错误: 检测到动态依赖!"
            exit 1
          fi
          
          # 检查静态链接
          if ldd "$BINARY" 2>&1 | grep -q "not a dynamic executable"; then
            echo "验证通过: 完全静态链接的可执行文件"
          else
            echo "错误: 不是静态可执行文件!"
            exit 1
          fi

      - name: Package Linux
        run: |
          mkdir -p package/extras
          cp ${{ env.CARGO_BUILD_DIR }}/ruffle_desktop package/ruffle
          cp README.md package/README.md
          cp LICENSE.md package/LICENSE.md
          cp desktop/packages/linux/rs.ruffle.Ruffle.desktop package/extras
          cp desktop/packages/linux/rs.ruffle.Ruffle.metainfo.xml package/extras
          cp desktop/packages/linux/rs.ruffle.Ruffle.svg package/extras

          cd package
          tar -czvf ../${{ env.PACKAGE_FILE }} *

      - name: Upload package
        run: gh release upload "${{ needs.create-nightly-release.outputs.tag_name }}" "${{ env.PACKAGE_FILE }}"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
